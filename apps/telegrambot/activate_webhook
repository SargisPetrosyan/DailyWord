import asyncio
import json
import logging
from dataclasses import dataclass
from uuid import uuid4

import uvicorn
from django.conf import settings
from django.core.asgi import get_asgi_application
from django.http import HttpRequest, HttpResponse, HttpResponseBadRequest
from django.urls import path
import os
from dotenv import load_dotenv

from telegram import Update,ReplyKeyboardMarkup,InlineKeyboardButton
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CallbackContext,
    ConversationHandler,
    ContextTypes,
    ExtBot,
    TypeHandler,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    
)

load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_BOT_CHAT_ID = os.getenv("TELEGRAM_BOT_CHAT_ID")
PUBLIC_URL="https://d37e-2a02-aa1-1056-bcde-b5a2-32c5-989-75b6.ngrok-free.app"
# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
# set higher logging level for httpx to avoid all GET and POST requests being logged
logging.getLogger("httpx").setLevel(logging.WARNING)

logger = logging.getLogger(__name__)

CONTINUE, NATIVE_LANGUAGE, LANGUAGE_TO_LEARN, = range(3)

languages_botton = [
    [
        InlineKeyboardButton("English", callback_data='english'),
        InlineKeyboardButton("Spanish", callback_data='spenish'),
        InlineKeyboardButton("French", callback_data='french'),
     ],
     [
        InlineKeyboardButton("German", callback_data='german'),
        InlineKeyboardButton("Italian", callback_data='italian'),
        InlineKeyboardButton("Chinese", callback_data='chinese'),
     ],
     [
        InlineKeyboardButton("Russian", callback_data='russian'),
        InlineKeyboardButton("Japanese", callback_data='japanese'),
        InlineKeyboardButton("Korean", callback_data='korean'),
     ],
     [
        InlineKeyboardButton("Hindi", callback_data='hindi'),
        InlineKeyboardButton("Arabic", callback_data='arabic'),
        InlineKeyboardButton("Portuguese", callback_data='portuguese'),
     ]
    ]

markup_languages = ReplyKeyboardMarkup(languages_botton, one_time_keyboard=True)


def facts_to_str(user_data: dict[str, str]) -> str:
    """Helper function for formatting the gathered user info."""
    facts = [f"{key} - {value}" for key, value in user_data.items()]
    return "\n".join(facts).join(["\n", "\n"])


async def start(update:Update, context: ContextTypes.DEFAULT_TYPE):
    """Start the conversation and ask user for input."""
    # Log the error for further inspection

    await update.message.reply_text(
"""Welcome to Daily Word Bot!
Your ultimate companion for building your vocabulary, one word at a time (or more)!

Here's what you can do:
📚 Explore Categories - Pick words from various categories that interest you.
📖 Save Words - Organize and save words in your personalized, categorized dictionaries.
📅 Daily Words - Get one or multiple words delivered to you every day!
📝  Take Quizzes - Challenge yourself with quizzes to reinforce your learning.

Just hit Start to begin your journey to mastering new words every day!🚀   
Let's make learning fun and exciting.
Ready to start? Tap continue! 👇
""",reply_markup=InlineKeyboardButton("Continue", callback_data ='continue')
    )

    return CONTINUE


async def native_language(update:Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        """Before we start, please select your languages:
        🌐 From: (Your native language)""",
    reply_markup=markup_languages
    )

    return LANGUAGE_TO_LEARN


async def language_to_learn(update:Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        """Now please select language that want to learn :
        🌐 From: (Your native language)""",
    reply_markup=markup_languages
    )

    return ENGLISH_KNOWLEGE_LEVEL


async def  english_knowlege_level(update:Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
    """ You’re almost ready to start!
    Please choose your English knowledge level:
 Don’t worry! During your learning journey, the bot will adapt to you—adjusting
the difficulty of words automatically based on how easy or hard they are for you.
Once you’ve selected your level, let’s get started! 
    """, reply_markup=markup_languages
    )
    return ConversationHandler.END

async def unknown(update:Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Sorry, I didn’t understand that. Please choose a valid option.")

#BOT ACTIVATION
# Define configuration constants
URL = PUBLIC_URL
ADMIN_CHAT_ID = TELEGRAM_BOT_CHAT_ID
PORT = 8000
TOKEN = f"{TELEGRAM_BOT_TOKEN}"  # nosec B105


@dataclass
class WebhookUpdate:
    """Simple dataclass to wrap a custom update type"""

    user_id: int
    payload: str


class CustomContext(CallbackContext[ExtBot, dict, dict, dict]):
    """
    Custom CallbackContext class that makes `user_data` available for updates of type
    `WebhookUpdate`.
    """

    @classmethod
    def from_update(
        cls,
        update: object,
        application: "Application",
    ) -> "CustomContext":
        if isinstance(update, WebhookUpdate):
            return cls(application=application, user_id=update.user_id)
        return super().from_update(update, application)


async def webhook_update(update: WebhookUpdate, context: CustomContext) -> None:
    """Handle custom updates."""
    chat_member = await context.bot.get_chat_member(chat_id=update.user_id, user_id=update.user_id)
    payloads = context.user_data.setdefault("payloads", [])
    payloads.append(update.payload)
    combined_payloads = "</code>\n• <code>".join(payloads)
    text = (
        f"The user {chat_member.user.mention_html()} has sent a new payload. "
        f"So far they have sent the following payloads: \n\n• <code>{combined_payloads}</code>"
    )
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=text, parse_mode=ParseMode.HTML)


async def telegram(request: HttpRequest) -> HttpResponse:
    """Handle incoming Telegram updates by putting them into the `update_queue`"""
    await ptb_application.update_queue.put(
        Update.de_json(data=json.loads(request.body), bot=ptb_application.bot)
    )
    return HttpResponse()


async def custom_updates(request: HttpRequest) -> HttpResponse:
    """
    Handle incoming webhook updates by also putting them into the `update_queue` if
    the required parameters were passed correctly.
    """
    try:
        user_id = int(request.GET["user_id"])
        payload = request.GET["payload"]
    except KeyError:
        return HttpResponseBadRequest(
            "Please pass both `user_id` and `payload` as query parameters.",
        )
    except ValueError:
        return HttpResponseBadRequest("The `user_id` must be a string!")

    await ptb_application.update_queue.put(WebhookUpdate(user_id=user_id, payload=payload))
     # Handle the update with the Application
    return HttpResponse()


# Set up PTB application and a web application for handling the incoming requests.
context_types = ContextTypes(context=CustomContext)
# Here we set updater to None because we want our custom webhook server to handle the updates
# and hence we don't need an Updater instance
ptb_application = (
    Application.builder().token(TOKEN).updater(None).context_types(context_types).build()
)

# register handlers
ptb_application.add_handler(TypeHandler(type=WebhookUpdate, callback=webhook_update))

conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            CONTINUE: [CallbackQueryHandler(native_language)],
            NATIVE_LANGUAGE: [CallbackQueryHandler(language_to_learn)]
        },
        fallbacks=[MessageHandler(filters.TEXT, unknown)]
    )

ptb_application.add_handler(conv_handler) 
ptb_application.add_handler(CommandHandler("start", start))

urlpatterns = [
    path("telegram", telegram, name="Telegram updates"),
    path("submitpayload", custom_updates, name="custom updates"),
]
settings.configure(ROOT_URLCONF=__name__, SECRET_KEY=uuid4().hex)


async def main() -> None:
    """Finalize configuration and run the applications."""
    webserver = uvicorn.Server(
        config=uvicorn.Config(
            app=get_asgi_application(),
            port=PORT,
            use_colors=False,
            host="127.0.0.1",
        )
    )

    # Pass webhook settings to telegram
    await ptb_application.bot.set_webhook(url=f"{URL}/telegram", allowed_updates=Update.ALL_TYPES)

    # Run application and webserver together
    async with ptb_application:
        await ptb_application.start()
        await webserver.serve()
        await ptb_application.stop()


if __name__ == "__main__":
    asyncio.run(main())
