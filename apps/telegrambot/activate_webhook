import asyncio
import json
import logging
from dataclasses import dataclass
from uuid import uuid4

import uvicorn
from django.conf import settings
from django.core.asgi import get_asgi_application
from django.http import HttpRequest, HttpResponse, HttpResponseBadRequest
from django.urls import path
import os
from dotenv import load_dotenv

from telegram import Update,ReplyKeyboardMarkup,InlineKeyboardButton
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CallbackContext,
    ConversationHandler,
    ContextTypes,
    ExtBot,
    TypeHandler,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    
)

load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_BOT_CHAT_ID = os.getenv("TELEGRAM_BOT_CHAT_ID")
PUBLIC_URL="https://d37e-2a02-aa1-1056-bcde-b5a2-32c5-989-75b6.ngrok-free.app"
# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
# set higher logging level for httpx to avoid all GET and POST requests being logged
logging.getLogger("httpx").setLevel(logging.WARNING)

logger = logging.getLogger(__name__)

CONTINUE, NATIVE_LANGUAGE, LANGUAGE_TO_LEARN, = range(3)

languages_botton = [
    [
        InlineKeyboardButton("English", callback_data='english'),
        InlineKeyboardButton("Spanish", callback_data='spenish'),
        InlineKeyboardButton("French", callback_data='french'),
     ],
     [
        InlineKeyboardButton("German", callback_data='german'),
        InlineKeyboardButton("Italian", callback_data='italian'),
        InlineKeyboardButton("Chinese", callback_data='chinese'),
     ],
     [
        InlineKeyboardButton("Russian", callback_data='russian'),
        InlineKeyboardButton("Japanese", callback_data='japanese'),
        InlineKeyboardButton("Korean", callback_data='korean'),
     ],
     [
        InlineKeyboardButton("Hindi", callback_data='hindi'),
        InlineKeyboardButton("Arabic", callback_data='arabic'),
        InlineKeyboardButton("Portuguese", callback_data='portuguese'),
     ]
    ]

markup_languages = ReplyKeyboardMarkup(languages_botton, one_time_keyboard=True)


def facts_to_str(user_data: dict[str, str]) -> str:
    """Helper function for formatting the gathered user info."""
    facts = [f"{key} - {value}" for key, value in user_data.items()]
    return "\n".join(facts).join(["\n", "\n"])


async def start(update:Update, context: ContextTypes.DEFAULT_TYPE):
    """Start the conversation and ask user for input."""
    # Log the error for further inspection

    await update.message.reply_text(
"""Welcome to Daily Word Bot!
Your ultimate companion for building your vocabulary, one word at a time (or more)!

Here's what you can do:
ðŸ“š Explore Categories - Pick words from various categories that interest you.
ðŸ“– Save Words - Organize and save words in your personalized, categorized dictionaries.
ðŸ“… Daily Words - Get one or multiple words delivered to you every day!
ðŸ“  Take Quizzes - Challenge yourself with quizzes to reinforce your learning.

Just hit Start to begin your journey to mastering new words every day!ðŸš€   
Let's make learning fun and exciting.
Ready to start? Tap continue! ðŸ‘‡
""",reply_markup=InlineKeyboardButton("Continue", callback_data ='continue')
    )

    return CONTINUE


async def native_language(update:Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        """Before we start, please select your languages:
        ðŸŒ From: (Your native language)""",
    reply_markup=markup_languages
    )

    return LANGUAGE_TO_LEARN


async def language_to_learn(update:Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        """Now please select language that want to learn :
        ðŸŒ From: (Your native language)""",
    reply_markup=markup_languages
    )

    return ENGLISH_KNOWLEGE_LEVEL


async def  english_knowlege_level(update:Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
    """ Youâ€™re almost ready to start!
    Please choose your English knowledge level:
 Donâ€™t worry! During your learning journey, the bot will adapt to youâ€”adjusting
the difficulty of words automatically based on how easy or hard they are for you.
Once youâ€™ve selected your level, letâ€™s get started! 
    """, reply_markup=markup_languages
    )
    return ConversationHandler.END

async def unknown(update:Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Sorry, I didnâ€™t understand that. Please choose a valid option.")

#BOT ACTIVATION
# Define configuration constants
URL = PUBLIC_URL
ADMIN_CHAT_ID = TELEGRAM_BOT_CHAT_ID
PORT = 8000
TOKEN = f"{TELEGRAM_BOT_TOKEN}"  # nosec B105


@dataclass
class WebhookUpdate:
    """Simple dataclass to wrap a custom update type"""

    user_id: int
    payload: str


class CustomContext(CallbackContext[ExtBot, dict, dict, dict]):
    """
    Custom CallbackContext class that makes `user_data` available for updates of type
    `WebhookUpdate`.
    """

    @classmethod
    def from_update(
        cls,
        update: object,
        application: "Application",
    ) -> "CustomContext":
        if isinstance(update, WebhookUpdate):
            return cls(application=application, user_id=update.user_id)
        return super().from_update(update, application)


async def webhook_update(update: WebhookUpdate, context: CustomContext) -> None:
    """Handle custom updates."""
    chat_member = await context.bot.get_chat_member(chat_id=update.user_id, user_id=update.user_id)
    payloads = context.user_data.setdefault("payloads", [])
    payloads.append(update.payload)
    combined_payloads = "</code>\nâ€¢ <code>".join(payloads)
    text = (
        f"The user {chat_member.user.mention_html()} has sent a new payload. "
        f"So far they have sent the following payloads: \n\nâ€¢ <code>{combined_payloads}</code>"
    )
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=text, parse_mode=ParseMode.HTML)


async def telegram(request: HttpRequest) -> HttpResponse:
    """Handle incoming Telegram updates by putting them into the `update_queue`"""
    await ptb_application.update_queue.put(
        Update.de_json(data=json.loads(request.body), bot=ptb_application.bot)
    )
    return HttpResponse()


async def custom_updates(request: HttpRequest) -> HttpResponse:
    """
    Handle incoming webhook updates by also putting them into the `update_queue` if
    the required parameters were passed correctly.
    """
    try:
        user_id = int(request.GET["user_id"])
        payload = request.GET["payload"]
    except KeyError:
        return HttpResponseBadRequest(
            "Please pass both `user_id` and `payload` as query parameters.",
        )
    except ValueError:
        return HttpResponseBadRequest("The `user_id` must be a string!")

    await ptb_application.update_queue.put(WebhookUpdate(user_id=user_id, payload=payload))
     # Handle the update with the Application
    return HttpResponse()


# Set up PTB application and a web application for handling the incoming requests.
context_types = ContextTypes(context=CustomContext)
# Here we set updater to None because we want our custom webhook server to handle the updates
# and hence we don't need an Updater instance
ptb_application = (
    Application.builder().token(TOKEN).updater(None).context_types(context_types).build()
)

# register handlers
ptb_application.add_handler(TypeHandler(type=WebhookUpdate, callback=webhook_update))

conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            CONTINUE: [CallbackQueryHandler(native_language)],
            NATIVE_LANGUAGE: [CallbackQueryHandler(language_to_learn)]
        },
        fallbacks=[MessageHandler(filters.TEXT, unknown)]
    )

ptb_application.add_handler(conv_handler) 
ptb_application.add_handler(CommandHandler("start", start))

urlpatterns = [
    path("telegram", telegram, name="Telegram updates"),
    path("submitpayload", custom_updates, name="custom updates"),
]
settings.configure(ROOT_URLCONF=__name__, SECRET_KEY=uuid4().hex)


async def main() -> None:
    """Finalize configuration and run the applications."""
    webserver = uvicorn.Server(
        config=uvicorn.Config(
            app=get_asgi_application(),
            port=PORT,
            use_colors=False,
            host="127.0.0.1",
        )
    )

    # Pass webhook settings to telegram
    await ptb_application.bot.set_webhook(url=f"{URL}/telegram", allowed_updates=Update.ALL_TYPES)

    # Run application and webserver together
    async with ptb_application:
        await ptb_application.start()
        await webserver.serve()
        await ptb_application.stop()


if __name__ == "__main__":
    asyncio.run(main())
